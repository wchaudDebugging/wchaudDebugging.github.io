<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wali Chaudhry — Portfolio & Visualizers</title>
<style>
  :root{
    --bg:#070708; --card:#0f1315; --muted:#9aa3ad; --accent:#4da3ff;
    --bfs:#4da3ff; --dfs:#7bf59b; --dijk:#ff8c6a;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Helvetica,Arial;
    background:linear-gradient(180deg,#050506 0%, #0b0b0d 100%);
    color:#e6eef6; -webkit-font-smoothing:antialiased;
  }
  header{ text-align:center; padding:48px 20px 28px; border-bottom:1px solid rgba(255,255,255,0.03) }
  .profile-img{ width:140px;height:140px;border-radius:50%;object-fit:cover;border:3px solid rgba(255,255,255,0.06); box-shadow:0 8px 30px rgba(0,0,0,0.6); display:block; margin:0 auto 16px; }
  header h1{margin:6px 0 4px;font-size:28px;letter-spacing:0.2px}
  header p{margin:0;color:var(--muted);font-size:14px}
  .wrap{max-width:1100px;margin:28px auto;padding:0 18px}
  .card{background:var(--card);border-radius:12px;padding:20px;margin-bottom:20px;box-shadow:0 6px 24px rgba(2,6,10,0.6)}
  h2{margin:0 0 12px;font-size:20px}
  .two-col{display:grid;grid-template-columns:1fr 380px;gap:18px}
  @media(max-width:1000px){.two-col{grid-template-columns:1fr;}}
  .viz{ background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.03) }
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
  button{background:var(--accent);color:#041423;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .muted{color:var(--muted);font-size:14px}
  canvas{border-radius:6px;display:block}
  .bars{display:flex;align-items:flex-end;height:220px;gap:4px;padding:12px;background:#070708;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .bar{flex:1;background:linear-gradient(180deg,#4da3ff,#2b8ce6);border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:#021022;font-weight:700;font-size:12px}
  .bar.alt{background:linear-gradient(180deg,#7bf59b,#4fe683)}
  .bar.third{background:linear-gradient(180deg,#ff8c6a,#ff6b4a)}
  .label{margin-top:8px;color:var(--muted);font-size:13px}
  .mini{font-size:13px;color:var(--muted)}
  .race-row{display:flex;gap:8px;align-items:flex-end}
  .finished-badge{display:inline-block;padding:6px 10px;border-radius:8px;background:#1b1b1b;color:#cde;text-transform:uppercase;font-weight:700}
</style>
</head>
<body>

<header>
  <img class="profile-img" src="/profile_cropped.png" alt="Wali Chaudhry">
  <h1>Wali Chaudhry</h1>
  <p class="muted">Software Engineer • Full-Stack • ASP.NET / Flutter / C# • Morton Grove, IL</p>
</header>

<main class="wrap">
  <div class="card">
    <h2>About</h2>
    <p class="muted">I build full-stack applications and enjoy creating interactive visualizations to explain algorithms. Below are two toy visualizers — a maze pathfinder (BFS / DFS / Dijkstra) and a sorting visualizer (multiple algorithms + race mode).</p>
  </div>

  <div class="two-col">
    <div>
      <!-- Maze Visualizer -->
      <div class="card viz" id="mazeCard">
        <h2>Maze visualizer — BFS / DFS / Dijkstra</h2>
        <canvas id="mazeCanvas" width="600" height="600" style="width:100%;height:auto;background:#060607"></canvas>
        <div class="controls">
          <button id="bfsBtn">Run BFS</button>
          <button id="dfsBtn">Run DFS</button>
          <button id="dijkBtn">Run Dijkstra</button>
          <button id="genMazeBtn" class="ghost">Generate Maze</button>
          <button id="resetMazeBtn" class="ghost">Reset Grid</button>
        </div>

        <div style="margin-top:10px" class="mini">
          <strong>Algorithm colors:</strong>
          <span style="color:var(--bfs)">● BFS</span>&nbsp;&nbsp;
          <span style="color:var(--dfs)">● DFS</span>&nbsp;&nbsp;
          <span style="color:var(--dijk)">● Dijkstra</span>
        </div>

        <div style="margin-top:12px" class="card" style="margin-top:12px;padding:12px">
          <strong>Complexity (worst-case):</strong>
          <ul class="muted">
            <li>BFS: Time O(V + E), Space O(V)</li>
            <li>DFS: Time O(V + E), Space O(V) (recursion/stack)</li>
            <li>Dijkstra: Time O(E + V log V) with a binary heap, Space O(V)</li>
          </ul>
        </div>

        <p class="label">Click cells to toggle walls. Start is top-left, End is bottom-right.</p>
      </div>

      <!-- Sorting Visualizer -->
      <div class="card viz" id="sortCard" style="margin-top:18px">
        <h2>Sorting visualizer</h2>
        <div style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
          <label class="mini">Algorithm:
            <select id="algoSelect">
              <option>Bubble</option>
              <option>Selection</option>
              <option>Insertion</option>
              <option>Merge</option>
              <option>Quick</option>
              <option>Heap</option>
            </select>
          </label>

          <label class="mini">Size:
            <input id="sizeRange" type="range" min="8" max="60" value="18">
          </label>

          <button id="resetArrayBtn" class="ghost">Reset Array</button>
          <button id="runSortBtn">Run Algorithm</button>
          <button id="shuffleBtn" class="ghost">Shuffle</button>
        </div>

        <div id="bars" class="bars" style="margin-top:12px"></div>

        <div class="card" style="margin-top:12px;padding:12px">
          <strong>Complexity (worst-case / average / space):</strong>
          <ul class="muted" id="sortComplexities">
            <!-- populated dynamically -->
          </ul>
        </div>

        <p class="label">Animations show swaps or comparisons. Use race mode below to compete two algorithms.</p>
      </div>

      <!-- Sorting Race -->
      <div class="card viz" style="margin-top:18px" id="raceCard">
        <h2>Sorting Race — compare two algorithms</h2>
        <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
          <label class="mini">Left:
            <select id="leftAlgo">
              <option>Quick</option><option>Merge</option><option>Heap</option><option>Bubble</option><option>Selection</option><option>Insertion</option>
            </select>
          </label>
          <label class="mini">Right:
            <select id="rightAlgo">
              <option>Heap</option><option>Quick</option><option>Merge</option><option>Bubble</option><option>Selection</option><option>Insertion</option>
            </select>
          </label>
          <label class="mini">Size:
            <input id="raceSize" type="range" min="10" max="80" value="40">
          </label>
          <button id="raceStartBtn">Start Race</button>
          <button id="raceResetBtn" class="ghost">Reset</button>
        </div>

        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px">
          <div>
            <div class="mini">Left — <span id="leftLabel">Quick</span> <span id="leftBadge"></span></div>
            <div id="leftBars" class="bars" style="height:200px"></div>
          </div>
          <div>
            <div class="mini">Right — <span id="rightLabel">Heap</span> <span id="rightBadge"></span></div>
            <div id="rightBars" class="bars" style="height:200px"></div>
          </div>
        </div>

      </div>
    </div>

    <!-- Right column: Resume / Skills -->
    <div>
      <div class="card">
        <h2>Experience</h2>
        <p class="muted"><strong>Software Engineer</strong> — MedSpeed (Jan 2025 – Sept 2025)</p>
        <ul class="muted">
          <li>Full-stack development: ASP.NET (C#) backend & Flutter (Dart) frontend</li>
          <li>Extended APIs & designed UI screens; created UI test coverage</li>
        </ul>
        <p class="muted"><strong>Associate Software Engineer</strong> — MedSpeed (Jan 2023 – Dec 2024)</p>
        <ul class="muted">
          <li>Updated and modernized internal mobile app; implemented REST APIs with Mulesoft</li>
        </ul>
        <p class="muted"><strong>SCSE Research Intern</strong> — NEIU (May 2021 – Aug 2021)</p>
      </div>

      <div class="card" style="margin-top:18px">
        <h2>Skills</h2>
        <p class="muted">C#, .NET, Flutter (Dart), JavaScript, React, Vue, Python, MySQL, Mulesoft, GitHub, Azure DevOps</p>
      </div>

    </div>
  </div>

  <div style="height:28px"></div>
  <footer style="text-align:center;color:var(--muted);font-size:13px">© 2025 Wali Chaudhry — Built with GitHub Pages</footer>
</main>

<script>
/* ======== Maze visualizer with BFS, DFS, Dijkstra ======== */
(() => {
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const cols = 24, rows = 24;
  const cellSize = Math.floor(canvas.width / cols);
  let grid = [];
  const start = [0,0], end = [rows-1, cols-1];

  function initGrid(){
    grid = [];
    for(let r=0;r<rows;r++){
      grid[r]=[];
      for(let c=0;c<cols;c++){
        grid[r][c]= {r,c,wall:false,visited:false,parent:null,dist:Infinity};
      }
    }
  }

  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[r][c];
        const x=c*cellSize, y=r*cellSize;
        ctx.fillStyle = cell.wall ? '#050506' : '#072430';
        ctx.fillRect(x,y,cellSize,cellSize);
        if(cell.visited){
          ctx.fillStyle = 'rgba(255,255,255,0.04)';
          ctx.fillRect(x+2,y+2,cellSize-4,cellSize-4);
        }
        if(r===start[0]&&c===start[1]){ ctx.fillStyle='#3ef5a4'; ctx.fillRect(x+3,y+3,cellSize-6,cellSize-6);}
        if(r===end[0]&&c===end[1]){ ctx.fillStyle='#ff9b78'; ctx.fillRect(x+3,y+3,cellSize-6,cellSize-6);}
        ctx.strokeStyle='rgba(255,255,255,0.03)'; ctx.strokeRect(x,y,cellSize,cellSize);
      }
    }
  }

  function neighbors(r,c){
    const list=[];
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
      const nr=r+dr, nc=c+dc;
      if(nr>=0 && nr<rows && nc>=0 && nc<cols && !grid[nr][nc].wall) list.push(grid[nr][nc]);
    });
    return list;
  }

  async function animateSearch(markColor, iterator){
    // iterator yields nodes as visited; it should set parent for path reconstruction
    for(const node of iterator){
      if(!node) continue;
      node.visited = true;
      drawGrid();
      // color this node for the algorithm
      ctx.fillStyle = markColor;
      ctx.fillRect(node.c*cellSize+3, node.r*cellSize+3, cellSize-6, cellSize-6);
      await sleep(12);
      if(node.r===end[0] && node.c===end[1]) break;
    }
    // draw final path if any
    await drawPath();
  }

  // BFS generator returns array (we'll use array since easier) of visited nodes in order
  function *bfsGen(){
    const q = [grid[start[0]][start[1]]];
    q[0].visited = false; // will be marked during animation
    const visitedOrder=[];
    const seen = new Set();
    seen.add(`${start[0]}_${start[1]}`);
    while(q.length){
      const cur = q.shift(); visitedOrder.push(cur);
      if(cur.r===end[0] && cur.c===end[1]) break;
      for(const n of neighbors(cur.r,cur.c)){
        const key = `${n.r}_${n.c}`;
        if(!seen.has(key)){
          seen.add(key); n.parent = cur; q.push(n);
        }
      }
    }
    return visitedOrder;
  }

  function *dfsGen(){
    const stack = [grid[start[0]][start[1]]];
    const visitedOrder=[];
    const seen = new Set();
    seen.add(`${start[0]}_${start[1]}`);
    while(stack.length){
      const cur = stack.pop(); visitedOrder.push(cur);
      if(cur.r===end[0] && cur.c===end[1]) break;
      for(const n of neighbors(cur.r,cur.c)){
        const key = `${n.r}_${n.c}`;
        if(!seen.has(key)){
          seen.add(key); n.parent = cur; stack.push(n);
        }
      }
    }
    return visitedOrder;
  }

  // Dijkstra (uses weights; here each non-wall edge has weight 1, but code supports weights)
  async function dijkstraAnim(){
    // reset dists
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){ grid[r][c].dist = Infinity; grid[r][c].parent = null; grid[r][c].visited=false; }
    const startNode = grid[start[0]][start[1]];
    startNode.dist = 0;
    const pq = new MinPQ(); pq.push(startNode,0);
    while(!pq.empty()){
      const cur = pq.pop();
      if(cur.visited) continue;
      cur.visited = true;
      drawGrid();
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--dijk') || '#ff8c6a';
      ctx.fillRect(cur.c*cellSize+3, cur.r*cellSize+3, cellSize-6, cellSize-6);
      await sleep(12);
      if(cur.r===end[0] && cur.c===end[1]) break;
      for(const n of neighbors(cur.r,cur.c)){
        const alt = cur.dist + 1; // uniform weight
        if(alt < n.dist){
          n.dist = alt; n.parent = cur; pq.push(n, alt);
        }
      }
    }
    await drawPath();
  }

  // helper PQ (binary heap simple)
  function MinPQ(){
    this.data=[];
    this.push = function(node,priority){
      this.data.push({node,priority});
      let i=this.data.length-1;
      while(i>0){
        let p=Math.floor((i-1)/2);
        if(this.data[p].priority <= this.data[i].priority) break;
        [this.data[p], this.data[i]] = [this.data[i], this.data[p]];
        i=p;
      }
    };
    this.pop = function(){
      if(this.data.length===0) return null;
      const top = this.data[0].node;
      const last = this.data.pop();
      if(this.data.length>0){
        this.data[0]=last;
        let i=0;
        while(true){
          let left=2*i+1, right=2*i+2, smallest=i;
          if(left < this.data.length && this.data[left].priority < this.data[smallest].priority) smallest=left;
          if(right < this.data.length && this.data[right].priority < this.data[smallest].priority) smallest=right;
          if(smallest===i) break;
          [this.data[i], this.data[smallest]]=[this.data[smallest], this.data[i]];
          i=smallest;
        }
      }
      return top;
    };
    this.empty = function(){ return this.data.length===0; };
  }

  async function runBFS(){ resetVisited(); const order = bfsGen(); await animateSearch(getComputedStyle(document.documentElement).getPropertyValue('--bfs') || '#4da3ff', order); }
  async function runDFS(){ resetVisited(); const order = dfsGen(); await animateSearch(getComputedStyle(document.documentElement).getPropertyValue('--dfs') || '#7bf59b', order); }

  async function drawPath(){
    let cur = grid[end[0]][end[1]];
    if(!cur.parent && cur!==grid[start[0]][start[1]]) return;
    const path = [];
    while(cur){
      path.push(cur); cur = cur.parent;
    }
    for(let i=path.length-1;i>=0;i--){
      const cell=path[i];
      ctx.fillStyle='rgba(255,140,106,0.95)';
      ctx.fillRect(cell.c*cellSize+4,cell.r*cellSize+4,cellSize-8,cellSize-8);
      await sleep(30);
    }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  function resetVisited(){ for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){ grid[r][c].visited=false; grid[r][c].parent=null; grid[r][c].dist=Infinity; } drawGrid(); }

  // small randomized wall generator
  function randomWalls(density=0.27){
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
      if((r===start[0]&&c===start[1])||(r===end[0]&&c===end[1])) { grid[r][c].wall=false; continue; }
      grid[r][c].wall = Math.random() < density;
    }
    drawGrid();
  }

  // click to toggle walls
  canvas.addEventListener('click',(ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const c = Math.floor(x / cellSize), r = Math.floor(y / cellSize);
    if(r>=0 && r<rows && c>=0 && c<cols){
      if(!(r===start[0]&&c===start[1]) && !(r===end[0]&&c===end[1])){
        grid[r][c].wall = !grid[r][c].wall;
        drawGrid();
      }
    }
  });

  // hooks
  document.getElementById('bfsBtn').addEventListener('click', ()=> runBFS());
  document.getElementById('dfsBtn').addEventListener('click', ()=> runDFS());
  document.getElementById('dijkBtn').addEventListener('click', ()=> dijkstraAnim());
  document.getElementById('genMazeBtn').addEventListener('click', ()=> { randomWalls(); });
  document.getElementById('resetMazeBtn').addEventListener('click', ()=> { initGrid(); drawGrid(); });

  // init
  initGrid(); randomWalls(0.22);
})();

/* ======== Sorting visualizer + Race + multiple algorithms ======== */
(() => {
  const bars = document.getElementById('bars');
  const algoSelect = document.getElementById('algoSelect');
  const sizeRange = document.getElementById('sizeRange');
  const runSortBtn = document.getElementById('runSortBtn');
  const resetArrayBtn = document.getElementById('resetArrayBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const complexitiesEl = document.getElementById('sortComplexities');

  let arr = [];
  let animSpeed = 80;
  function randArray(n=18){
    const a=[];
    for(let i=0;i<n;i++) a.push(Math.floor(5 + Math.random()*95));
    return a;
  }
  function renderArray(a, highlight=[]){
    bars.innerHTML='';
    const max = Math.max(...a);
    for(let i=0;i<a.length;i++){
      const val=a[i];
      const div=document.createElement('div');
      div.className='bar';
      div.style.height = Math.max(6, Math.round((val/max)*200)) + 'px';
      div.textContent = val;
      if(highlight.includes(i)) div.style.background='linear-gradient(180deg,#ff8c6a,#ff6b4a)';
      bars.appendChild(div);
    }
  }

  // helper: run animations (actions list: {type:'swap'|'set', i, j, value})
  async function runAnimations(a, actions){
    for(const act of actions){
      if(act.type==='compare'){
        renderArray(a, [act.i, act.j]);
        await sleep(animSpeed/1.2);
      } else if(act.type==='swap'){
        const tmp=a[act.i]; a[act.i]=a[act.j]; a[act.j]=tmp;
        renderArray(a, [act.i, act.j]); await sleep(animSpeed);
      } else if(act.type==='set'){
        a[act.i]=act.value;
        renderArray(a, [act.i]); await sleep(animSpeed);
      }
    }
    renderArray(a);
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // Sorting algorithms produce action lists (non-blocking)
  function bubbleActions(a){
    const actions=[];
    const arr = a.slice();
    for(let i=0;i<arr.length;i++){
      for(let j=0;j<arr.length-1-i;j++){
        actions.push({type:'compare', i:j, j:j+1});
        if(arr[j] > arr[j+1]){
          actions.push({type:'swap', i:j, j:j+1});
          [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
        }
      }
    }
    return actions;
  }

  function selectionActions(a){
    const actions=[]; const arr=a.slice();
    for(let i=0;i<arr.length-1;i++){
      let min=i;
      for(let j=i+1;j<arr.length;j++){
        actions.push({type:'compare', i:min, j:j});
        if(arr[j] < arr[min]) min=j;
      }
      if(min !== i){
        actions.push({type:'swap', i:i, j:min});
        [arr[i], arr[min]] = [arr[min], arr[i]];
      }
    }
    return actions;
  }

  function insertionActions(a){
    const actions=[]; const arr=a.slice();
    for(let i=1;i<arr.length;i++){
      let key = arr[i]; let j=i-1;
      while(j>=0 && arr[j] > key){
        actions.push({type:'compare', i:j, j:i});
        arr[j+1]=arr[j];
        actions.push({type:'set', i:j+1, value:arr[j+1]});
        j--;
      }
      arr[j+1]=key;
      actions.push({type:'set', i:j+1, value:key});
    }
    return actions;
  }

  function mergeActions(a){
    const actions=[]; const arr=a.slice();
    function mergeSort(l, r){
      if(l>=r) return;
      const m = Math.floor((l+r)/2);
      mergeSort(l,m); mergeSort(m+1,r);
      // merge
      const left = arr.slice(l,m+1), right = arr.slice(m+1,r+1);
      let i=0,j=0,k=l;
      while(i<left.length && j<right.length){
        actions.push({type:'compare', i:l+i, j:m+1+j});
        if(left[i] <= right[j]){ arr[k]=left[i]; actions.push({type:'set', i:k, value:left[i]}); i++; }
        else{ arr[k]=right[j]; actions.push({type:'set', i:k, value:right[j]}); j++; }
        k++;
      }
      while(i<left.length){ arr[k]=left[i]; actions.push({type:'set', i:k, value:left[i]}); i++; k++; }
      while(j<right.length){ arr[k]=right[j]; actions.push({type:'set', i:k, value:right[j]}); j++; k++; }
    }
    mergeSort(0, arr.length-1);
    return actions;
  }

  function quickActions(a){
    const actions=[]; const arr=a.slice();
    function q(l,r){
      if(l>=r) return;
      const pivot = arr[Math.floor((l+r)/2)];
      let i=l,j=r;
      while(i<=j){
        while(arr[i] < pivot){ actions.push({type:'compare', i:i, j:Math.floor((l+r)/2)}); i++; }
        while(arr[j] > pivot){ actions.push({type:'compare', i:j, j:Math.floor((l+r)/2)}); j--; }
        if(i<=j){
          actions.push({type:'swap', i:i, j:j}); [arr[i], arr[j]]=[arr[j], arr[i]]; i++; j--;
        }
      }
      if(l<j) q(l,j);
      if(i<r) q(i,r);
    }
    q(0,arr.length-1);
    return actions;
  }

  function heapActions(a){
    const actions=[]; const arr=a.slice();
    function heapify(n,i){
      let largest=i; const l=2*i+1, r=2*i+2;
      if(l<n){ actions.push({type:'compare', i:l, j:largest}); if(arr[l]>arr[largest]) largest=l; }
      if(r<n){ actions.push({type:'compare', i:r, j:largest}); if(arr[r]>arr[largest]) largest=r; }
      if(largest!==i){ actions.push({type:'swap', i:i, j:largest}); [arr[i],arr[largest]]=[arr[largest],arr[i]]; heapify(n,largest); }
    }
    for(let i=Math.floor(arr.length/2)-1;i>=0;i--) heapify(arr.length,i);
    for(let i=arr.length-1;i>0;i--){
      actions.push({type:'swap', i:0, j:i}); [arr[0],arr[i]]=[arr[i],arr[0]];
      heapify(i,0);
    }
    return actions;
  }

  function getActionsFor(algo, a){
    switch(algo){
      case 'Bubble': return bubbleActions(a);
      case 'Selection': return selectionActions(a);
      case 'Insertion': return insertionActions(a);
      case 'Merge': return mergeActions(a);
      case 'Quick': return quickActions(a);
      case 'Heap': return heapActions(a);
      default: return bubbleActions(a);
    }
  }

  // Complexity map
  const complexities = {
    'Bubble': {time:'O(n^2) / O(n^2) / O(n^2)', space:'O(1)'},
    'Selection': {time:'O(n^2)', space:'O(1)'},
    'Insertion': {time:'O(n^2) / O(n^2) / O(n)', space:'O(1)'},
    'Merge': {time:'O(n log n)', space:'O(n)'},
    'Quick': {time:'O(n^2) / O(n log n) / O(n log n)', space:'O(log n)'},
    'Heap': {time:'O(n log n)', space:'O(1)'}
  };

  function updateComplexityText(){
    const a = algoSelect.value;
    const c = complexities[a];
    complexitiesEl.innerHTML = `<li>${a}: Time (worst/average/best): ${c.time}</li><li>Space: ${c.space}</li>`;
  }

  // event handlers
  sizeRange.addEventListener('input', ()=> {
    arr = randArray(parseInt(sizeRange.value,10));
    renderArray(arr);
  });

  shuffleBtn.addEventListener('click', ()=> { arr = randArray(parseInt(sizeRange.value,10)); renderArray(arr); });
  resetArrayBtn.addEventListener('click', ()=> { arr = randArray(parseInt(sizeRange.value,10)); renderArray(arr); updateComplexityText(); });
  algoSelect.addEventListener('change', ()=> updateComplexityText());

  runSortBtn.addEventListener('click', async ()=>{
    runSortBtn.disabled = true;
    const actions = getActionsFor(algoSelect.value, arr.slice());
    await runAnimations(arr, actions);
    runSortBtn.disabled = false;
  });

  // init
  arr = randArray(parseInt(sizeRange.value,10)); renderArray(arr); updateComplexityText();

  /* ===== Race mode code ===== */
  const leftAlgo = document.getElementById('leftAlgo');
  const rightAlgo = document.getElementById('rightAlgo');
  const leftBars = document.getElementById('leftBars');
  const rightBars = document.getElementById('rightBars');
  const leftLabel = document.getElementById('leftLabel');
  const rightLabel = document.getElementById('rightLabel');
  const raceStartBtn = document.getElementById('raceStartBtn');
  const leftBadge = document.getElementById('leftBadge');
  const rightBadge = document.getElementById('rightBadge');
  const raceSize = document.getElementById('raceSize');
  const raceResetBtn = document.getElementById('raceResetBtn');

  function renderBarsTo(container, a, colorClass=''){
    container.innerHTML='';
    const max = Math.max(...a);
    for(let i=0;i<a.length;i++){
      const val=a[i];
      const div=document.createElement('div');
      div.className='bar';
      if(colorClass==='alt') div.className='bar alt';
      if(colorClass==='third') div.className='bar third';
      div.style.height = Math.max(6, Math.round((val/max)*160)) + 'px';
      div.textContent = val;
      container.appendChild(div);
    }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function playActionsOn(container, a, actions, colorClass){
    for(const act of actions){
      if(act.type==='compare'){ renderBarsTo(container, a, colorClass); highlightTwo(container, act.i, act.j); await sleep(10); }
      else if(act.type==='swap'){ [a[act.i], a[act.j]]=[a[act.j], a[act.i]]; renderBarsTo(container, a, colorClass); await sleep(10); }
      else if(act.type==='set'){ a[act.i]=act.value; renderBarsTo(container, a, colorClass); await sleep(10); }
    }
    renderBarsTo(container, a, colorClass);
  }

  function highlightTwo(container, i, j){
    const nodes = container.children;
    for(let k=0;k<nodes.length;k++){
      nodes[k].style.opacity = 0.6;
    }
    if(nodes[i]) nodes[i].style.opacity=1;
    if(nodes[j]) nodes[j].style.opacity=1;
  }

  raceStartBtn.addEventListener('click', async ()=>{
    // disable controls
    raceStartBtn.disabled = true; raceResetBtn.disabled = true;
    leftBadge.textContent = ''; rightBadge.textContent = '';
    leftLabel.textContent = leftAlgo.value; rightLabel.textContent = rightAlgo.value;
    const n = parseInt(raceSize.value,10);
    const base = randArray(n);
    const leftArr = base.slice(); const rightArr = base.slice();

    // generate actions
    const leftActions = getActionsFor(leftAlgo.value, leftArr.slice());
    const rightActions = getActionsFor(rightAlgo.value, rightArr.slice());

    // run both concurrently and detect winner
    let leftDone=false, rightDone=false;
    const leftPromise = (async ()=>{ await playActionsOn(leftBars, leftArr, leftActions, 'alt'); leftDone=true; return 'left'; })();
    const rightPromise = (async ()=>{ await playActionsOn(rightBars, rightArr, rightActions, 'third'); rightDone=true; return 'right'; })();

    // poll for completion
    const winner = await Promise.race([leftPromise, rightPromise]);
    if(winner==='left'){ leftBadge.innerHTML = '<span class="finished-badge">Winner</span>'; }
    else { rightBadge.innerHTML = '<span class="finished-badge">Winner</span>'; }

    // await both to fully finish
    await Promise.all([leftPromise, rightPromise]);
    raceStartBtn.disabled = false; raceResetBtn.disabled = false;
  });

  raceResetBtn.addEventListener('click', ()=>{
    leftBars.innerHTML=''; rightBars.innerHTML=''; leftBadge.textContent=''; rightBadge.textContent='';
    const n = parseInt(raceSize.value,10); const base = randArray(n);
    renderBarsTo(leftBars, base.slice(), 'alt'); renderBarsTo(rightBars, base.slice(), 'third');
  });

  // initialize race bars
  renderBarsTo(leftBars, randArray(parseInt(raceSize.value,10)), 'alt');
  renderBarsTo(rightBars, randArray(parseInt(raceSize.value,10)), 'third');

})();
</script>

</body>
</html>
