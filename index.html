<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wali Chaudhry — Portfolio & Visualizers</title>
<style>
  :root{
    --bg:#0b0b0d; --card:#0f1315; --muted:#9aa3ad; --accent:#4da3ff;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Helvetica,Arial;
    background:linear-gradient(180deg,#050506 0%, #0b0b0d 100%);
    color:#e6eef6; -webkit-font-smoothing:antialiased;
  }
  header{
    text-align:center; padding:48px 20px 28px; border-bottom:1px solid rgba(255,255,255,0.03)
  }
  .profile-img{
    width:140px;height:140px;border-radius:50%;object-fit:cover;border:3px solid rgba(255,255,255,0.06);
    box-shadow:0 8px 30px rgba(0,0,0,0.6); display:block; margin:0 auto 16px;
  }
  header h1{margin:6px 0 4px;font-size:28px;letter-spacing:0.2px}
  header p{margin:0;color:var(--muted);font-size:14px}
  .wrap{max-width:980px;margin:28px auto;padding:0 18px}
  .card{background:var(--card);border-radius:12px;padding:20px;margin-bottom:20px;box-shadow:0 6px 24px rgba(2,6,10,0.6)}
  h2{margin:0 0 12px;font-size:20px}
  .two-col{display:grid;grid-template-columns:1fr 420px;gap:18px}
  @media(max-width:900px){.two-col{grid-template-columns:1fr;}}
  /* Visualizer canvas styling */
  .viz {
    background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent);
    border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.03)
  }
  .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
  button{background:var(--accent);color:#041423;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .muted{color:var(--muted);font-size:14px}
  /* sorting bars */
  .bars{display:flex;align-items:flex-end;height:220px;gap:4px;padding:12px;background:#0b0b0d;border-radius:6px;border:1px solid rgba(255,255,255,0.02)}
  .bar{flex:1;background:linear-gradient(180deg,#4da3ff,#2b8ce6);border-radius:4px;display:flex;align-items:flex-end;justify-content:center;color:#021022;font-weight:700;font-size:12px}
  .bar.small{font-size:10px}
  .label{margin-top:8px;color:var(--muted);font-size:13px}
</style>
</head>
<body>

<header>
  <img class="profile-img" src="/profile_cropped.png" alt="Wali Chaudhry">
  <h1>Wali Chaudhry</h1>
  <p class="muted">Software Engineer • Full-Stack • ASP.NET / Flutter / C# • Morton Grove, IL</p>
</header>

<main class="wrap">
  <div class="card">
    <h2>About</h2>
    <p class="muted">I build full-stack applications and enjoy creating interactive visualizations to explain algorithms. Below are a couple of toy visualizers — a maze pathfinder (BFS / DFS) and a sorting visualizer (Bubble Sort) (Test).</p>
  </div>

  <div class="two-col">
    <div>
      <!-- Maze Visualizer Card -->
      <div class="card viz" id="mazeCard">
        <h2>Maze visualizer — BFS / DFS</h2>
        <canvas id="mazeCanvas" width="600" height="600" style="width:100%;height:auto;display:block;border-radius:6px;background:#060607"></canvas>
        <div class="controls">
          <button id="bfsBtn">Run BFS</button>
          <button id="dfsBtn">Run DFS</button>
          <button id="genMazeBtn" class="ghost">Generate Maze</button>
          <button id="resetMazeBtn" class="ghost">Reset Grid</button>
        </div>
        <p class="label">Click cells to toggle walls. Start is top-left, End is bottom-right.</p>
      </div>

      <!-- Sorting Visualizer Card -->
      <div class="card viz" id="sortCard" style="margin-top:18px">
        <h2>Sorting visualizer — Bubble Sort</h2>
        <div id="bars" class="bars"></div>
        <div class="controls">
          <button id="shuffleBtn">Reset Array</button>
          <button id="runSortBtn">Run Bubble Sort</button>
          <button id="speedDown" class="ghost">Slower</button>
          <button id="speedUp" class="ghost">Faster</button>
        </div>
        <p class="label">A simple in-browser animation of bubble sort. Values shown at top of bars.</p>
      </div>
    </div>

    <!-- Right column: Resume / Skills -->
    <div>
      <div class="card">
        <h2>Experience</h2>
        <p class="muted"><strong>Software Engineer</strong> — MedSpeed (Jan 2025 – Sept 2025)</p>
        <ul class="muted">
          <li>Full-stack development: ASP.NET (C#) backend & Flutter (Dart) frontend</li>
          <li>Extended APIs & designed UI screens; created UI test coverage</li>
        </ul>
        <p class="muted"><strong>Associate Software Engineer</strong> — MedSpeed (Jan 2023 – Dec 2024)</p>
        <ul class="muted">
          <li>Updated and modernized internal mobile app; implemented REST APIs with Mulesoft</li>
        </ul>
        <p class="muted"><strong>SCSE Research Intern</strong> — NEIU (May 2021 – Aug 2021)</p>
      </div>

      <div class="card" style="margin-top:18px">
        <h2>Skills</h2>
        <p class="muted">C#, .NET, Flutter (Dart), JavaScript, React, Vue, Python, MySQL, Mulesoft, GitHub, Azure DevOps</p>
      </div>

    </div>
  </div>

  <div style="height:28px"></div>
  <footer style="text-align:center;color:var(--muted);font-size:13px">© 2025 Wali Chaudhry — Built with GitHub Pages</footer>
</main>

<script>
/* ---------- MAZE VISUALIZER ---------- */
(() => {
  const canvas = document.getElementById('mazeCanvas');
  const ctx = canvas.getContext('2d');
  const cols = 20, rows = 20;
  const cellSize = Math.floor(canvas.width / cols);
  let grid = [];
  let start = [0,0], end = [rows-1, cols-1];

  function initGrid() {
    grid = [];
    for (let r=0;r<rows;r++){
      grid[r]=[];
      for (let c=0;c<cols;c++){
        grid[r][c]={r,c,wall:false,visited:false,parent:null};
      }
    }
  }

  function drawGrid() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const cell = grid[r][c];
        const x=c*cellSize, y=r*cellSize;
        // background
        ctx.fillStyle = cell.wall ? '#111' : '#0b2b3b';
        ctx.fillRect(x,y,cellSize,cellSize);
        // visited overlay
        if(cell.visited){
          ctx.fillStyle='rgba(77,163,255,0.35)';
          ctx.fillRect(x+2,y+2,cellSize-4,cellSize-4);
        }
        // start / end
        if(r===start[0] && c===start[1]){
          ctx.fillStyle = '#7bf59b'; ctx.fillRect(x+2,y+2,cellSize-4,cellSize-4);
        }
        if(r===end[0] && c===end[1]){
          ctx.fillStyle = '#ff8c6a'; ctx.fillRect(x+2,y+2,cellSize-4,cellSize-4);
        }
        // grid lines
        ctx.strokeStyle='rgba(255,255,255,0.03)';
        ctx.strokeRect(x,y,cellSize,cellSize);
      }
    }
  }

  function neighbors(r,c){
    const list=[];
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
      const nr=r+dr, nc=c+dc;
      if(nr>=0 && nr<rows && nc>=0 && nc<cols && !grid[nr][nc].wall) list.push(grid[nr][nc]);
    });
    return list;
  }

  // BFS algorithm (animated)
  async function runBFS() {
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){grid[r][c].visited=false;grid[r][c].parent=null;}
    const q=[grid[start[0]][start[1]]];
    grid[start[0]][start[1]].visited=true;
    let found=false;
    while(q.length){
      const cur=q.shift();
      if(cur.r===end[0] && cur.c===end[1]){ found=true; break; }
      for(const n of neighbors(cur.r,cur.c)){
        if(!n.visited){ n.visited=true; n.parent=cur; q.push(n); }
      }
      drawGrid();
      await sleep(20);
    }
    if(found) await drawPath();
  }

  // DFS algorithm (animated)
  async function runDFS(){
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){grid[r][c].visited=false;grid[r][c].parent=null;}
    const stack=[grid[start[0]][start[1]]];
    grid[start[0]][start[1]].visited=true;
    let found=false;
    while(stack.length){
      const cur=stack.pop();
      if(cur.r===end[0] && cur.c===end[1]){ found=true; break; }
      for(const n of neighbors(cur.r,cur.c)){
        if(!n.visited){ n.visited=true; n.parent=cur; stack.push(n); }
      }
      drawGrid();
      await sleep(20);
    }
    if(found) await drawPath();
  }

  async function drawPath(){
    let cur = grid[end[0]][end[1]];
    const path=[];
    while(cur){
      path.push(cur); cur=cur.parent;
    }
    for(let i=path.length-1;i>=0;i--){
      const cell=path[i];
      const x=cell.c*cellSize, y=cell.r*cellSize;
      ctx.fillStyle='rgba(255,140,106,0.95)';
      ctx.fillRect(x+4,y+4,cellSize-8,cellSize-8);
      await sleep(35);
    }
  }

  function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

  // simple randomized maze generator (recursive division not perfect, but quick)
  function generateRandomWalls(density=0.25){
    for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
      // keep start/end open
      if((r===start[0]&&c===start[1])||(r===end[0]&&c===end[1])) { grid[r][c].wall=false; continue; }
      grid[r][c].wall = Math.random() < density;
    }
  }

  // click to toggle walls
  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const c = Math.floor(x / cellSize);
    const r = Math.floor(y / cellSize);
    if(r>=0 && r<rows && c>=0 && c<cols){
      // toggle unless start or end
      if(!(r===start[0]&&c===start[1]) && !(r===end[0]&&c===end[1])){
        grid[r][c].wall = !grid[r][c].wall;
        drawGrid();
      }
    }
  });

  document.getElementById('bfsBtn').addEventListener('click', ()=>{ runBFS(); });
  document.getElementById('dfsBtn').addEventListener('click', ()=>{ runDFS(); });
  document.getElementById('genMazeBtn').addEventListener('click', ()=>{ generateRandomWalls(); drawGrid(); });
  document.getElementById('resetMazeBtn').addEventListener('click', ()=>{ initGrid(); drawGrid(); });

  // initial
  initGrid();
  drawGrid();

})();

/* ---------- SORTING VISUALIZER (Bubble Sort) ---------- */
(() => {
  const barsContainer = document.getElementById('bars');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const runSortBtn = document.getElementById('runSortBtn');
  const speedUp = document.getElementById('speedUp');
  const speedDown = document.getElementById('speedDown');

  let arr = [];
  let speed = 200; // ms
  const n = 18;

  function randArray(){
    arr = [];
    for(let i=0;i<n;i++) arr.push(Math.floor(10+Math.random()*90));
    renderBars();
  }

  function renderBars(highlightIndexes=[]){
    barsContainer.innerHTML='';
    const max = Math.max(...arr);
    for(let i=0;i<arr.length;i++){
      const val = arr[i];
      const bar = document.createElement('div');
      bar.className = 'bar';
      const h = Math.max(6, Math.round((val/max)*200));
      bar.style.height = h + 'px';
      bar.style.flex = (1);
      bar.textContent = val;
      if(highlightIndexes.includes(i)){
        bar.style.background = 'linear-gradient(180deg,#ff8c6a,#ff6b4a)';
      }
      barsContainer.appendChild(bar);
    }
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  async function bubbleSort(){
    for(let i=0;i<arr.length;i++){
      for(let j=0;j<arr.length - 1 - i;j++){
        renderBars([j,j+1]);
        await sleep(speed);
        if(arr[j] > arr[j+1]){
          const tmp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=tmp;
          renderBars([j,j+1]);
          await sleep(speed);
        }
      }
    }
    renderBars();
  }

  shuffleBtn.addEventListener('click', ()=> randArray());
  runSortBtn.addEventListener('click', ()=> bubbleSort());
  speedUp.addEventListener('click', ()=> { speed = Math.max(10, Math.floor(speed/1.5)); });
  speedDown.addEventListener('click', ()=> { speed = Math.min(1000, Math.floor(speed*1.5)); });

  // init
  randArray();
})();
</script>

</body>
</html>
